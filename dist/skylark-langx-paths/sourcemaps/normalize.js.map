{"version":3,"sources":["normalize.js"],"names":["define","paths","normalize","p","absolute","charAt","sep","components","_removeDuplicateSeps","split","goodComponents","idx","length","c","pop","push","unshift","join"],"mappings":";;;;;;;AAAAA,QACC,WACC,SAASC,GA8DP,OAAOA,EAAMC,UAlDZ,SAAmBC,GAEN,KAANA,IACAA,EAAI,KAUR,IANA,IAAIC,EAAWD,EAAEE,OAAO,KAAOJ,EAAMK,IAIjCC,GAFJJ,EAAIF,EAAMO,qBAAqBL,IAEZM,MAAMR,EAAMK,KAC3BI,KACKC,EAAM,EAAGA,EAAMJ,EAAWK,OAAQD,IAAO,CAC9C,IAAIE,EAAIN,EAAWI,GACT,MAANE,IAGW,OAANA,IAAeT,IAAcA,GAAYM,EAAeE,OAAS,GAA2B,OAAtBF,EAAe,IAK1FA,EAAeI,MAGfJ,EAAeK,KAAKF,IAM5B,IAAKT,GAAYM,EAAeE,OAAS,EACrC,OAAQF,EAAeE,QACnB,KAAK,EACyB,KAAtBF,EAAe,IACfA,EAAeM,QAAQ,KAE3B,MACJ,QACIN,EAAeK,KAAK,KAOhC,OAJAZ,EAAIO,EAAeO,KAAKhB,EAAMK,KAC1BF,GAAYD,EAAEE,OAAO,KAAOJ,EAAMK,MAClCH,EAAIF,EAAMK,IAAMH,GAEbA","file":"../normalize.js","sourcesContent":["define([\r\n\t\"./paths\"\r\n],function(paths){\r\n    /**\r\n     * Normalize a string path, taking care of '..' and '.' parts.\r\n     *\r\n     * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\r\n     * @example Usage example\r\n     *   paths.normalize('/foo/bar//baz/asdf/quux/..')\r\n     *   // returns\r\n     *   '/foo/bar/baz/asdf'\r\n     * @param [String] p The path to normalize.\r\n     * @return [String]\r\n     */\r\n     function normalize(p) {\r\n        // Special case: '' -> '.'\r\n        if (p === '') {\r\n            p = '.';\r\n        }\r\n        // It's very important to know if the path is relative or not, since it\r\n        // changes how we process .. and reconstruct the split string.\r\n        var absolute = p.charAt(0) === paths.sep;\r\n        // Remove repeated //s\r\n        p = paths._removeDuplicateSeps(p);\r\n        // Try to remove as many '../' as possible, and remove '.' completely.\r\n        var components = p.split(paths.sep);\r\n        var goodComponents = [];\r\n        for (var idx = 0; idx < components.length; idx++) {\r\n            var c = components[idx];\r\n            if (c === '.') {\r\n                continue;\r\n            }\r\n            else if (c === '..' && (absolute || (!absolute && goodComponents.length > 0 && goodComponents[0] !== '..'))) {\r\n                // In the absolute case: Path is relative to root, so we may pop even if\r\n                // goodComponents is empty (e.g. /../ => /)\r\n                // In the relative case: We're getting rid of a directory that preceded\r\n                // it (e.g. /foo/../bar -> /bar)\r\n                goodComponents.pop();\r\n            }\r\n            else {\r\n                goodComponents.push(c);\r\n            }\r\n        }\r\n        // Add in '.' when it's a relative path with no other nonempty components.\r\n        // Possible results: '.' and './' (input: [''] or [])\r\n        // @todo Can probably simplify this logic.\r\n        if (!absolute && goodComponents.length < 2) {\r\n            switch (goodComponents.length) {\r\n                case 1:\r\n                    if (goodComponents[0] === '') {\r\n                        goodComponents.unshift('.');\r\n                    }\r\n                    break;\r\n                default:\r\n                    goodComponents.push('.');\r\n            }\r\n        }\r\n        p = goodComponents.join(paths.sep);\r\n        if (absolute && p.charAt(0) !== paths.sep) {\r\n            p = paths.sep + p;\r\n        }\r\n        return p;\r\n    }\r\n\r\n    return paths.normalize = normalize;\r\n});"]}