{"version":3,"sources":["relative.js"],"names":["define","paths","resolve","relative","from","to","i","fromSegs","split","sep","toSegs","shift","upCount","downSegs","length","slice","rv","join","charAt","substr"],"mappings":";;;;;;;AAAAA,QACC,UACA,aACC,SAASC,EAAMC,GA2Eb,OAAOD,EAAME,SApDb,SAAkBC,EAAMC,GACpB,IAAIC,EAGJF,EAAOF,EAAQE,GACfC,EAAKH,EAAQG,GACb,IAAIE,EAAWH,EAAKI,MAAMP,EAAMQ,KAC5BC,EAASL,EAAGG,MAAMP,EAAMQ,KAE5BC,EAAOC,QACPJ,EAASI,QAIT,IAAIC,EAAU,EACVC,KAEJ,IAAKP,EAAI,EAAGA,EAAIC,EAASO,OAAQR,IAE7B,GADUC,EAASD,KACPI,EAAOJ,GAAnB,CAKAM,EAAUL,EAASO,OAASR,EAC5B,MAIJO,EAAWH,EAAOK,MAAMT,GAEA,IAApBC,EAASO,QAAgC,KAAhBP,EAAS,KAClCK,EAAU,GAIVA,EAAUL,EAASO,SACnBF,EAAUL,EAASO,QAGvB,IAAIE,EAAK,GACT,IAAKV,EAAI,EAAGA,EAAIM,EAASN,IACrBU,GAAM,MAOV,OALAA,GAAMH,EAASI,KAAKhB,EAAMQ,MAEnBK,OAAS,GAAKE,EAAGE,OAAOF,EAAGF,OAAS,KAAOb,EAAMQ,MACpDO,EAAKA,EAAGG,OAAO,EAAGH,EAAGF,OAAS,IAE3BE","file":"../relative.js","sourcesContent":["define([\r\n\t\"./paths\",\r\n\t\"./resolve\"\r\n],function(paths,resolve){\r\n\r\n    /**\r\n     * Solve the relative path from from to to.\r\n     *\r\n     * At times we have two absolute paths, and we need to derive the relative path\r\n     * from one to the other. This is actually the reverse transform of\r\n     * paths.resolve, which means we see that:\r\n     *\r\n     *    paths.resolve(from, paths.relative(from, to)) == paths.resolve(to)\r\n     *\r\n     * @example Usage example\r\n     *   paths.relative('C:\\\\orandea\\\\test\\\\aaa', 'C:\\\\orandea\\\\impl\\\\bbb')\r\n     *   // returns\r\n     *   '..\\\\..\\\\impl\\\\bbb'\r\n     *\r\n     *   paths.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\r\n     *   // returns\r\n     *   '../../impl/bbb'\r\n     * @param [String] from\r\n     * @param [String] to\r\n     * @return [String]\r\n     */\r\n    function relative(from, to) {\r\n        var i;\r\n        // Alright. Let's resolve these two to absolute paths and remove any\r\n        // weirdness.\r\n        from = resolve(from);\r\n        to = resolve(to);\r\n        var fromSegs = from.split(paths.sep);\r\n        var toSegs = to.split(paths.sep);\r\n        // Remove the first segment on both, as it's '' (both are absolute paths)\r\n        toSegs.shift();\r\n        fromSegs.shift();\r\n        // There are two segments to this path:\r\n        // * Going *up* the directory hierarchy with '..'\r\n        // * Going *down* the directory hierarchy with foo/baz/bat.\r\n        var upCount = 0;\r\n        var downSegs = [];\r\n        // Figure out how many things in 'from' are shared with 'to'.\r\n        for (i = 0; i < fromSegs.length; i++) {\r\n            var seg = fromSegs[i];\r\n            if (seg === toSegs[i]) {\r\n                continue;\r\n            }\r\n            // The rest of 'from', including the current element, indicates how many\r\n            // directories we need to go up.\r\n            upCount = fromSegs.length - i;\r\n            break;\r\n        }\r\n        // The rest of 'to' indicates where we need to change to. We place this\r\n        // outside of the loop, as toSegs.length may be greater than fromSegs.length.\r\n        downSegs = toSegs.slice(i);\r\n        // Special case: If 'from' is '/'\r\n        if (fromSegs.length === 1 && fromSegs[0] === '') {\r\n            upCount = 0;\r\n        }\r\n        // upCount can't be greater than the number of fromSegs\r\n        // (cd .. from / is still /)\r\n        if (upCount > fromSegs.length) {\r\n            upCount = fromSegs.length;\r\n        }\r\n        // Create the final string!\r\n        var rv = '';\r\n        for (i = 0; i < upCount; i++) {\r\n            rv += '../';\r\n        }\r\n        rv += downSegs.join(paths.sep);\r\n        // Special case: Remove trailing '/'. Happens if it's all up and no down.\r\n        if (rv.length > 1 && rv.charAt(rv.length - 1) === paths.sep) {\r\n            rv = rv.substr(0, rv.length - 1);\r\n        }\r\n        return rv;\r\n    }\r\n\r\n    return paths.relative =  relative;\r\n});"]}