{"version":3,"sources":["skylark-langx-paths.js"],"names":["define","skylark","paths","_makeLong","p","_removeDuplicateSeps","replace","this","_replaceRegex","sep","RegExp","delimiter","posix","win32","attach","basename","ext","sections","normalize","split","lastPart","length","lastPartExt","substr","dirname","absolute","charAt","pop","join","components","goodComponents","idx","c","push","unshift","extname","i","lastIndexOf","format","pathObject","TypeError","root","dir","base","isAbsolute","_i","arguments","processed","segment","types","constructs","Path","klass","_construct","_","segments","hasLeading","hasTrailing","isString","_parse","isArray","_canonicalize","doIt","stack","_length","anotherPath","path","shift","append","tail","appendPathStr","appendPath","mySegments","tailSegments","newSegments","concat","result","clone","endsWith","equals","another","anotherSegments","firstSegment","getExtension","extension","textension","getSegments","getParentPath","parentPath","parentSegments","getRoot","lastSegment","matchingFirstSegments","pathSegments","max","Math","min","count","removeFirstSegments","slice","removeLastSegments","removeMatchingFirstSegments","match","removeMatchingLastSegments","removeRelative","segs","relativeTo","ignoreFilename","baseSegments","commonLength","baseSegmentLength","differenceLength","newSegmentLength","EMPTY","index","startsWith","toString","get","relative","from","to","resolve","fromSegs","toSegs","upCount","downSegs","seg","rv","resolved","cwd","process","main"],"mappings":"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","file":"../skylark-langx-paths.js","sourcesContent":["define('skylark-langx-paths/paths',[\r\n\t\"skylark-langx-ns\"\r\n],function(skylark){\r\n\tvar splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\n\r\n\tfunction posixSplitPath(filename) {\r\n\t    var out = splitPathRe.exec(filename);\r\n\t    out.shift();\r\n\t    return out;\r\n\t}\r\n\t/**\r\n\t * Emulates Node's `path` module. This module contains utilities for handling and\r\n\t * transforming file paths. **All** of these methods perform only string\r\n\t * transformations. The file system is not consulted to check whether paths are\r\n\t * valid.\r\n\t * @see http://nodejs.org/api/path.html\r\n\t * @class\r\n\t */\r\n\tvar paths = {};\r\n\r\n\r\n    /**\r\n     * Unknown. Undocumented.\r\n     */\r\n    paths._makeLong = function (p) {\r\n        return p;\r\n    };\r\n\r\n\r\n    paths._removeDuplicateSeps = function (p) {\r\n        p = p.replace(this._replaceRegex, this.sep);\r\n        return p;\r\n    };\r\n\r\n    // The platform-specific file separator. BrowserFS uses `/`.\r\n    paths.sep = '/';\r\n    paths._replaceRegex = new RegExp(\"//+\", 'g');\r\n    // The platform-specific path delimiter. BrowserFS uses `:`.\r\n    paths.delimiter = ':';\r\n    paths.posix = paths;\r\n    // XXX: Typing hack. We don't actually support win32.\r\n    paths.win32 = paths;\r\n\r\n\r\n\treturn skylark.attach(\"langx.paths\",paths);\r\n});\ndefine('skylark-langx-paths/basename',[\r\n\t\"./paths\"\r\n],function(paths){\r\n    /**\r\n     * Return the last portion of a path. Similar to the Unix basename command.\r\n     * @example Usage example\r\n     *   paths.basename('/foo/bar/baz/asdf/quux.html')\r\n     *   // returns\r\n     *   'quux.html'\r\n     *\r\n     *   paths.basename('/foo/bar/baz/asdf/quux.html', '.html')\r\n     *   // returns\r\n     *   'quux'\r\n     * @param [String] p\r\n     * @param [String?] ext\r\n     * @return [String]\r\n     */\r\n    function basename(p, ext) {\r\n        if (ext === void 0) { ext = \"\"; }\r\n        // Special case: Normalize will modify this to '.'\r\n        if (p === '') {\r\n            return p;\r\n        }\r\n        // Normalize the string first to remove any weirdness.\r\n        p = paths.normalize(p);\r\n        // Get the last part of the string.\r\n        var sections = p.split(paths.sep);\r\n        var lastPart = sections[sections.length - 1];\r\n        // Special case: If it's empty, then we have a string like so: foo/\r\n        // Meaning, 'foo' is guaranteed to be a directory.\r\n        if (lastPart === '' && sections.length > 1) {\r\n            return sections[sections.length - 2];\r\n        }\r\n        // Remove the extension, if need be.\r\n        if (ext.length > 0) {\r\n            var lastPartExt = lastPart.substr(lastPart.length - ext.length);\r\n            if (lastPartExt === ext) {\r\n                return lastPart.substr(0, lastPart.length - ext.length);\r\n            }\r\n        }\r\n        return lastPart;\r\n    }\r\n\r\n    return paths.basename = basename;\r\n});\ndefine('skylark-langx-paths/dirname',[\r\n\t\"./paths\"\r\n],function(paths){\r\n    /**\r\n     * Return the directory name of a path. Similar to the Unix `dirname` command.\r\n     *\r\n     * Note that BrowserFS does not validate if the path is actually a valid\r\n     * directory.\r\n     * @example Usage example\r\n     *   paths.dirname('/foo/bar/baz/asdf/quux')\r\n     *   // returns\r\n     *   '/foo/bar/baz/asdf'\r\n     * @param [String] p The path to get the directory name of.\r\n     * @return [String]\r\n     */\r\n    function dirname(p) {\r\n        // We get rid of //, but we don't modify anything else (e.g. any extraneous .\r\n        // and ../ are kept intact)\r\n        p = paths._removeDuplicateSeps(p);\r\n        var absolute = p.charAt(0) === paths.sep;\r\n        var sections = p.split(paths.sep);\r\n        // Do 1 if it's /foo/bar, 2 if it's /foo/bar/\r\n        if (sections.pop() === '' && sections.length > 0) {\r\n            sections.pop();\r\n        }\r\n        // # of sections needs to be > 1 if absolute, since the first section is '' for '/'.\r\n        // If not absolute, the first section is the first part of the path, and is OK\r\n        // to return.\r\n        if (sections.length > 1 || (sections.length === 1 && !absolute)) {\r\n            return sections.join(paths.sep);\r\n        }\r\n        else if (absolute) {\r\n            return paths.sep;\r\n        }\r\n        else {\r\n            return '.';\r\n        }\r\n    }\r\n\r\n    return paths.dirname = dirname;\r\n});\ndefine('skylark-langx-paths/normalize',[\r\n\t\"./paths\"\r\n],function(paths){\r\n    /**\r\n     * Normalize a string path, taking care of '..' and '.' parts.\r\n     *\r\n     * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\r\n     * @example Usage example\r\n     *   paths.normalize('/foo/bar//baz/asdf/quux/..')\r\n     *   // returns\r\n     *   '/foo/bar/baz/asdf'\r\n     * @param [String] p The path to normalize.\r\n     * @return [String]\r\n     */\r\n     function normalize(p) {\r\n        // Special case: '' -> '.'\r\n        if (p === '') {\r\n            p = '.';\r\n        }\r\n        // It's very important to know if the path is relative or not, since it\r\n        // changes how we process .. and reconstruct the split string.\r\n        var absolute = p.charAt(0) === paths.sep;\r\n        // Remove repeated //s\r\n        p = paths._removeDuplicateSeps(p);\r\n        // Try to remove as many '../' as possible, and remove '.' completely.\r\n        var components = p.split(paths.sep);\r\n        var goodComponents = [];\r\n        for (var idx = 0; idx < components.length; idx++) {\r\n            var c = components[idx];\r\n            if (c === '.') {\r\n                continue;\r\n            }\r\n            else if (c === '..' && (absolute || (!absolute && goodComponents.length > 0 && goodComponents[0] !== '..'))) {\r\n                // In the absolute case: Path is relative to root, so we may pop even if\r\n                // goodComponents is empty (e.g. /../ => /)\r\n                // In the relative case: We're getting rid of a directory that preceded\r\n                // it (e.g. /foo/../bar -> /bar)\r\n                goodComponents.pop();\r\n            }\r\n            else {\r\n                goodComponents.push(c);\r\n            }\r\n        }\r\n        // Add in '.' when it's a relative path with no other nonempty components.\r\n        // Possible results: '.' and './' (input: [''] or [])\r\n        // @todo Can probably simplify this logic.\r\n        if (!absolute && goodComponents.length < 2) {\r\n            switch (goodComponents.length) {\r\n                case 1:\r\n                    if (goodComponents[0] === '') {\r\n                        goodComponents.unshift('.');\r\n                    }\r\n                    break;\r\n                default:\r\n                    goodComponents.push('.');\r\n            }\r\n        }\r\n        p = goodComponents.join(paths.sep);\r\n        if (absolute && p.charAt(0) !== paths.sep) {\r\n            p = paths.sep + p;\r\n        }\r\n        return p;\r\n    }\r\n\r\n    return paths.normalize = normalize;\r\n});\ndefine('skylark-langx-paths/extname',[\r\n\t\"./paths\",\r\n    \"./normalize\"\r\n],function(paths,normalize){\r\n    /**\r\n     * Return the extension of the path, from the last '.' to end of string in the\r\n     * last portion of the path. If there is no '.' in the last portion of the path\r\n     * or the first character of it is '.', then it returns an empty string.\r\n     * @example Usage example\r\n     *   paths.extname('index.html')\r\n     *   // returns\r\n     *   '.html'\r\n     *\r\n     *   paths.extname('index.')\r\n     *   // returns\r\n     *   '.'\r\n     *\r\n     *   paths.extname('index')\r\n     *   // returns\r\n     *   ''\r\n     * @param [String] p\r\n     * @return [String]\r\n     */\r\n    function extname(p) {\r\n        p = normalize(p);\r\n        var sections = p.split(paths.sep);\r\n        p = sections.pop();\r\n        // Special case: foo/file.ext/ should return '.ext'\r\n        if (p === '' && sections.length > 0) {\r\n            p = sections.pop();\r\n        }\r\n        if (p === '..') {\r\n            return '';\r\n        }\r\n        var i = p.lastIndexOf('.');\r\n        if (i === -1 || i === 0) {\r\n            return '';\r\n        }\r\n        return p.substr(i);\r\n    }\r\n\r\n    return paths.extname = extname;\r\n});\ndefine('skylark-langx-paths/format',[\r\n\t\"./paths\"\r\n],function(paths){\r\n    function format(pathObject) {\r\n        if (pathObject === null || typeof pathObject !== 'object') {\r\n            throw new TypeError(\"Parameter 'pathObject' must be an object, not \" + typeof pathObject);\r\n        }\r\n        var root = pathObject.root || '';\r\n        if (typeof root !== 'string') {\r\n            throw new TypeError(\"'pathObject.root' must be a string or undefined, not \" +\r\n                typeof pathObject.root);\r\n        }\r\n        var dir = pathObject.dir ? pathObject.dir + paths.sep : '';\r\n        var base = pathObject.base || '';\r\n        return dir + base;\r\n    }\r\n\r\n    return paths.format = format;\r\n});\ndefine('skylark-langx-paths/is-absolute',[\r\n\t\"./paths\"\r\n],function(paths){\r\n\r\n    /**\r\n     * Checks if the given path is an absolute path.\r\n     *\r\n     * Despite not being documented, this is a tested part of Node's path API.\r\n     * @param [String] p\r\n     * @return [Boolean] True if the path appears to be an absolute path.\r\n     */\r\n    function isAbsolute(p) {\r\n        return p.length > 0 && p.charAt(0) === paths.sep;\r\n    }\r\n\r\n    return paths.isAbsolute = isAbsolute;\r\n\r\n});\ndefine('skylark-langx-paths/join',[\r\n\t\"./paths\",\r\n    \"./normalize\"\r\n],function(paths,normalize){\r\n    /**\r\n     * Join all arguments together and normalize the resulting path.\r\n     *\r\n     * Arguments must be strings.\r\n     * @example Usage\r\n     *   paths.join('/foo', 'bar', 'baz/asdf', 'quux', '..')\r\n     *   // returns\r\n     *   '/foo/bar/baz/asdf'\r\n     *\r\n     *   paths.join('foo', {}, 'bar')\r\n     *   // throws exception\r\n     *   TypeError: Arguments to paths.join must be strings\r\n     * @param [String,...] paths Each component of the path\r\n     * @return [String]\r\n     */\r\n    function join() {\r\n        var paths = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            paths[_i - 0] = arguments[_i];\r\n        }\r\n        // Required: Prune any non-strings from the path. I also prune empty segments\r\n        // so we can do a simple join of the array.\r\n        var processed = [];\r\n        for (var i = 0; i < paths.length; i++) {\r\n            var segment = paths[i];\r\n            if (typeof segment !== 'string') {\r\n                throw new TypeError(\"Invalid argument type to paths.join: \" + (typeof segment));\r\n            }\r\n            else if (segment !== '') {\r\n                processed.push(segment);\r\n            }\r\n        }\r\n        return normalize(processed.join(paths.sep));\r\n    }\r\n\r\n    return paths.join = join;\r\n});\ndefine('skylark-langx-paths/path',[\r\n    \"skylark-langx-types\",\r\n    \"skylark-langx-constructs\",\r\n    \"./paths\"\r\n], function(types,constructs,paths) {\r\n\r\n    /**\r\n     * @class Path\r\n     * @constructor\r\n     */\r\n    var Path =   constructs.klass({\r\n        _construct : function() {\r\n            var _ = this._ = {\r\n                segments : null,\r\n                hasLeading : false,\r\n                hasTrailing : false\r\n            };\r\n            if (arguments.length == 1 && types.isString(arguments[0])) {\r\n                  this._parse(arguments[0]);\r\n            } else  if (types.isArray(arguments[0])){\r\n                _.segments = arguments[0];\r\n                _.hasLeading = arguments[1] || false;\r\n                _.hasTrailing = arguments[2] || false;\r\n                this._canonicalize();                \r\n            }\r\n        },\r\n\r\n        _canonicalize: function() {\r\n            var doIt;\r\n            var segments = this._.segments;\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (segments[i] == \".\" || segments[i] == \"..\") {\r\n                    doIt = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (doIt) {\r\n                var stack = [];\r\n                for (var i = 0; i < segments.length; i++) {\r\n                    if (segments[i] == \"..\") {\r\n                        if (stack.length == 0) {\r\n                            // if the stack is empty we are going out of our scope\r\n                            // so we need to accumulate segments.  But only if the original\r\n                            // path is relative.  If it is absolute then we can't go any higher than\r\n                            // root so simply toss the .. references.\r\n                            if (!this.hasLeading) {\r\n                                stack.push(segments[i]); //stack push\r\n                            }\r\n                        } else {\r\n                            // if the top is '..' then we are accumulating segments so don't pop\r\n                            if (\"..\" == stack[stack.length - 1]) {\r\n                                stack.push(\"..\");\r\n                            } else {\r\n                                stack.pop();\r\n                            }\r\n                        }\r\n                        //collapse current references\r\n                    } else if (segments[i] != \".\" || segments.length == 1) {\r\n                        stack.push(segments[i]); //stack push\r\n                    }\r\n                }\r\n                //if the number of segments hasn't changed, then no modification needed\r\n                if (stack.length == segments.length) {\r\n                    return;\r\n                }\r\n                this._.segments = stack;\r\n            }\r\n        },\r\n\r\n        _length: function(anotherPath) {\r\n            return this._.segments.length;\r\n        },\r\n\r\n\r\n        _parse : function( /*String*/ path) {\r\n            if (!path) {\r\n                path = \".\";\r\n            }\r\n            var _ = this._,\r\n                segments = path.split(\"/\");\r\n\r\n            if (path.charAt(0) == \"/\") {\r\n                _.hasLeading = true;\r\n                segments.shift();\r\n            }\r\n            if (path.charAt(path.length - 1) == \"/\") {\r\n                _.hasTrailing = true;\r\n                // If the path ends in '/', split() will create an array whose last element\r\n                // is an empty string. Remove that here.\r\n                segments.pop();\r\n            }\r\n            _.segments = segments;\r\n            _.path = path;\r\n\r\n            this._canonicalize()\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method append\r\n         *@parameter {Path|String}tail\r\n         *@return {Path}\r\n         */\r\n        append: /*Path*/ function( /*Path*/ tail) {\r\n            if (types.isString(tail)) {\r\n                return this.appendPathStr(tail);\r\n            } else {\r\n                return this.appendPath(tail);\r\n            }\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method appendPath\r\n         *@parameter {Path}tail\r\n         *@return {Path}\r\n         */\r\n        appendPath: /*Path*/ function( /*Path*/ tail) {\r\n            if (tail.isAbsolute()) {\r\n                return tail;\r\n            }\r\n            var mySegments = this.segments,\r\n                tailSegments = tail.segments,\r\n                newSegments = mySegments.concat(tailSegments),\r\n                result = new Path(newSegments, this.hasLeading, tail.hasTrailing);\r\n            return result;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method appendPathStr\r\n         *@parameter {String}tail\r\n         *@return {Path}\r\n         */\r\n        appendPathStr: function( /*String*/ tail) {\r\n            tail = new Path(tail || \"\");\r\n            return this.appendPath(tail);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method clone\r\n         *@return {Path}\r\n         */\r\n        \"clone\": function() {\r\n            return new Path(this.segments, this.hasLeading, this.hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *Tests if this path ends with the given path.\r\n         *@method endsWidth\r\n         *@parameter {String}tail\r\n         *@return {Boolean}\r\n         */\r\n        \"endsWith\": /*Boolean*/ function( /*String*/ tail) {\r\n            var segments = this.segments;\r\n            var tailSegments = (new Path(tail)).segments;\r\n            while (tailSegments.length > 0 && segments.length > 0) {\r\n                if (tailSegments.pop() != segments.pop()) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        },\r\n\r\n        /*\r\n         *Tests this path for equality with the given object.\r\n         *@method equals\r\n         *@parameter {Path}another\r\n         *@return {Boolean}\r\n         */\r\n        \"equals\": /*Boolean*/ function( /*Path*/ another) {\r\n            var segments = this._.segments,\r\n                anotherSegments = another._.segments;\r\n            if (segments.length != anotherSegments.length) {\r\n                return false;\r\n            }\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (anotherSegments[i] != segments[i]) {\r\n                    return false;\r\n                };\r\n            }\r\n            return true;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method firstSegment\r\n         *@parameter {Number}length\r\n         *@return {String}\r\n         */\r\n        firstSegment: /*String*/ function( /*Number*/ length) {\r\n            var segments = this._.segments;\r\n            return segments[length || 0];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method getExtension\r\n         *@return {String}\r\n         */\r\n        getExtension: function() {\r\n            var extension = this._.extension,\r\n                path = this._.path;\r\n            if (!textension) {\r\n                extension = this._.extension = path.substr(path.lastIndexOf('.') + 1);\r\n            }\r\n            return extension;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method getSegments\r\n         *@return {Array}\r\n         */\r\n        getSegments: /*Array*/ function() {\r\n            return this.segments;\r\n        },\r\n\r\n        /*\r\n         *Returns the parent path, or null if this path does not have a parent.\r\n         *@method getParentPath\r\n         *@return {Path}\r\n         */\r\n        getParentPath: /*Path*/ function() {\r\n            var parentPath = this._.parentPath;\r\n            if (!parentPath) {\r\n                var parentSegments = this.segments;\r\n                parentSegments.pop();\r\n                parentPath = this._.parentPath = new Path(parentSegments, this.hasLeading);\r\n            }\r\n            return parentPath;\r\n        },\r\n\r\n\r\n        /*\r\n         *Returns the root component of this path as a Path object, or null if this path does not have a root component.\r\n         *@method getRoot\r\n         *@return {Path}\r\n         */\r\n        \"getRoot\": /*Path*/ function() {\r\n            //TODO: will be implemented\r\n        },\r\n\r\n        /*\r\n         *Tells whether or not this path is absolute.\r\n         *@method isAbsolute\r\n         *@return {Boolean}\r\n         */\r\n        isAbsolute: /*Boolean*/ function() {\r\n            return this.hasLeading;\r\n        },\r\n\r\n\r\n        /*\r\n         *\r\n         *@method lastSegment\r\n         *@ return {String}\r\n         */\r\n        lastSegment: /*String*/ function() {\r\n            var segments = this._.segments;\r\n            return segments[segments.length - 1];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method matchingFirstSegments\r\n         *@parameter {Path}another\r\n         *@return {Number}\r\n         */\r\n        matchingFirstSegments: /*Number*/ function( /*Path*/ another) {\r\n            var mySegments = this.segments;\r\n            var pathSegments = another.segments;\r\n            var max = Math.min(mySegments.length, pathSegments.length);\r\n            var count = 0;\r\n            for (var i = 0; i < max; i++) {\r\n                if (mySegments[i] != pathSegments[i]) {\r\n                    return count;\r\n                }\r\n                count++;\r\n            }\r\n            return count;\r\n        },\r\n\r\n        /*\r\n         *Returns a path that is this path with redundant name elements eliminated.\r\n         *@method normalize\r\n         *@return {Path}\r\n         */\r\n        \"normalize\": /*Path*/ function() {\r\n            //TODO: will be implemented\r\n        },\r\n\r\n\r\n        /*\r\n         *\r\n         *@method removeFirstSegments\r\n         *@parameter {Number}count\r\n         *@return {Path}\r\n         */\r\n        removeFirstSegments: /*Path*/ function( /*Number*/ count) {\r\n            var segments = this._.segments,\r\n                hasLeading = this._.hasLeading;\r\n            hasTrailing = this._.hasTrailing;\r\n\r\n            return new Path(segments.slice(count, segments.length), hasLeading, hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeLastSegments\r\n         *@parameter {Number}count\r\n         *@return {Path}\r\n         */\r\n        removeLastSegments: /*Path*/ function( /*Number?*/ count) {\r\n            var segments = this._.segments,\r\n                hasLeading = this._.hasLeading;\r\n            hasTrailing = this._.hasTrailing;\r\n\r\n            if (!count) {\r\n                count = 1;\r\n            }\r\n\r\n            return new Path(segments.slice(0, segments.length - count), hasLeading, hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeMatchingFirstSegments\r\n         *@parameter {Path}another\r\n         *@return {Path}\r\n         */\r\n        removeMatchingFirstSegments: /*Path*/ function( /*Path*/ another) {\r\n            var match = this.matchingFirstSegments(another);\r\n            return this.removeFirstSegments(match);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeMatchingLastSegments\r\n         *@parameter {Path}another\r\n         *@return {Path}\r\n         */\r\n        removeMatchingLastSegments: /*Path*/ function( /*Path*/ another) {\r\n            var match = this.matchingFirstSegments(anotherPath);\r\n            return this.removeLastSegments(match);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeRelative\r\n         *@return {Path}\r\n         */\r\n        removeRelative: function() {\r\n            var segs = this.segments;\r\n            if (segs.length > 0 && segs[1] == \".\")\r\n                return this.removeFirstSegments(1);\r\n            return this;\r\n        },\r\n\r\n        /*\r\n         *Constructs a relative path between this path and a given path.\r\n         *@method relativeTo\r\n         *@parameter {Path}base\r\n         *@return {Path}\r\n         */\r\n        relativeTo: /*Path*/ function( /*Path|String*/ base, /*Boolean*/ ignoreFilename) {\r\n            if (typeof base == 'string') {\r\n                base = new Path(base);\r\n            }\r\n            var mySegments = this.segments;\r\n            if (this.isAbsolute()) {\r\n                return this;\r\n            }\r\n            var baseSegments = base.segments;\r\n            var commonLength = this.matchingFirstSegments(base);\r\n            var baseSegmentLength = baseSegments.length;\r\n            if (ignoreFilename) {\r\n                baseSegmentLength = baseSegmentLength - 1;\r\n            }\r\n            var differenceLength = baseSegmentLength - commonLength;\r\n            var newSegmentLength = differenceLength + mySegments.length - commonLength;\r\n            if (newSegmentLength == 0) {\r\n                return Path.EMPTY;\r\n            }\r\n            var newSegments = [];\r\n            for (var i = 0; i < differenceLength; i++) {\r\n                newSegments.push('..');\r\n            }\r\n            for (var i = commonLength; i < mySegments.length; i++) {\r\n                newSegments.push(mySegments[i]);\r\n            }\r\n            return new Path(newSegments, false, this.hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method segment\r\n         *@parameter {Number}index\r\n         *@return {String}\r\n         */\r\n        segment: /*String*/ function( /*Number*/ index) {\r\n            var segments = this._.segments;\r\n            if (segments.length < index) return null;\r\n            return segments[index];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method startsWith\r\n         *@parameter {Path}index\r\n         *@return {Boolean}\r\n         */\r\n        startsWith: /*Boolean*/ function( /*Path*/ another) {\r\n            var count = this.matchingFirstSegments(another);\r\n            return another._length() == count;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method toString\r\n         *@return {String}\r\n         */\r\n        toString: function() {\r\n            var result = [],\r\n                segments = this._.segments;\r\n            if (this.hasLeading) {\r\n                result.push(\"/\");\r\n            }\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (i > 0) {\r\n                    result.push(\"/\");\r\n                }\r\n                result.push(segments[i]);\r\n            }\r\n            if (this.hasTrailing) {\r\n                result.push(\"/\");\r\n            }\r\n            return result.join(\"\");\r\n        },\r\n\r\n        hasLeading : {\r\n            get : function() {\r\n                return this._.hasLeading\r\n            }\r\n        },\r\n\r\n        hasTrailing : {\r\n            get : function() {\r\n                return this._.hasTrailing\r\n            }\r\n        }\r\n\r\n    });\r\n\r\n\r\n    Path.EMPTY = new Path(\"\");\r\n\r\n    return paths.Path = Path;\r\n});\r\n\ndefine('skylark-langx-paths/relative',[\r\n\t\"./paths\"\r\n],function(paths){\r\n\r\n    /**\r\n     * Solve the relative path from from to to.\r\n     *\r\n     * At times we have two absolute paths, and we need to derive the relative path\r\n     * from one to the other. This is actually the reverse transform of\r\n     * paths.resolve, which means we see that:\r\n     *\r\n     *    paths.resolve(from, paths.relative(from, to)) == paths.resolve(to)\r\n     *\r\n     * @example Usage example\r\n     *   paths.relative('C:\\\\orandea\\\\test\\\\aaa', 'C:\\\\orandea\\\\impl\\\\bbb')\r\n     *   // returns\r\n     *   '..\\\\..\\\\impl\\\\bbb'\r\n     *\r\n     *   paths.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\r\n     *   // returns\r\n     *   '../../impl/bbb'\r\n     * @param [String] from\r\n     * @param [String] to\r\n     * @return [String]\r\n     */\r\n    function relative(from, to) {\r\n        var i;\r\n        // Alright. Let's resolve these two to absolute paths and remove any\r\n        // weirdness.\r\n        from = paths.resolve(from);\r\n        to = paths.resolve(to);\r\n        var fromSegs = from.split(paths.sep);\r\n        var toSegs = to.split(paths.sep);\r\n        // Remove the first segment on both, as it's '' (both are absolute paths)\r\n        toSegs.shift();\r\n        fromSegs.shift();\r\n        // There are two segments to this path:\r\n        // * Going *up* the directory hierarchy with '..'\r\n        // * Going *down* the directory hierarchy with foo/baz/bat.\r\n        var upCount = 0;\r\n        var downSegs = [];\r\n        // Figure out how many things in 'from' are shared with 'to'.\r\n        for (i = 0; i < fromSegs.length; i++) {\r\n            var seg = fromSegs[i];\r\n            if (seg === toSegs[i]) {\r\n                continue;\r\n            }\r\n            // The rest of 'from', including the current element, indicates how many\r\n            // directories we need to go up.\r\n            upCount = fromSegs.length - i;\r\n            break;\r\n        }\r\n        // The rest of 'to' indicates where we need to change to. We place this\r\n        // outside of the loop, as toSegs.length may be greater than fromSegs.length.\r\n        downSegs = toSegs.slice(i);\r\n        // Special case: If 'from' is '/'\r\n        if (fromSegs.length === 1 && fromSegs[0] === '') {\r\n            upCount = 0;\r\n        }\r\n        // upCount can't be greater than the number of fromSegs\r\n        // (cd .. from / is still /)\r\n        if (upCount > fromSegs.length) {\r\n            upCount = fromSegs.length;\r\n        }\r\n        // Create the final string!\r\n        var rv = '';\r\n        for (i = 0; i < upCount; i++) {\r\n            rv += '../';\r\n        }\r\n        rv += downSegs.join(paths.sep);\r\n        // Special case: Remove trailing '/'. Happens if it's all up and no down.\r\n        if (rv.length > 1 && rv.charAt(rv.length - 1) === paths.sep) {\r\n            rv = rv.substr(0, rv.length - 1);\r\n        }\r\n        return rv;\r\n    }\r\n\r\n    return paths.relative =  relative;\r\n});\ndefine('skylark-langx-paths/resolve',[\r\n\t\"./paths\",\r\n\t\"./normalize\"\r\n],function(paths,normalize){\r\n    /**\r\n     * Resolves to to an absolute path.\r\n     *\r\n     * If to isn't already absolute from arguments are prepended in right to left\r\n     * order, until an absolute path is found. If after using all from paths still\r\n     * no absolute path is found, the current working directory is used as well.\r\n     * The resulting path is normalized, and trailing slashes are removed unless\r\n     * the path gets resolved to the root directory. Non-string arguments are\r\n     * ignored.\r\n     *\r\n     * Another way to think of it is as a sequence of cd commands in a shell.\r\n     *\r\n     *     paths.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')\r\n     *\r\n     * Is similar to:\r\n     *\r\n     *     cd foo/bar\r\n     *     cd /tmp/file/\r\n     *     cd ..\r\n     *     cd a/../subfile\r\n     *     pwd\r\n     *\r\n     * The difference is that the different paths don't need to exist and may also\r\n     * be files.\r\n     * @example Usage example\r\n     *   paths.resolve('/foo/bar', './baz')\r\n     *   // returns\r\n     *   '/foo/bar/baz'\r\n     *\r\n     *   paths.resolve('/foo/bar', '/tmp/file/')\r\n     *   // returns\r\n     *   '/tmp/file'\r\n     *\r\n     *   paths.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')\r\n     *   // if currently in /home/myself/node, it returns\r\n     *   '/home/myself/node/wwwroot/static_files/gif/image.gif'\r\n     * @param [String,...] paths\r\n     * @return [String]\r\n     */\r\n    function resolve() {\r\n        var paths = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            paths[_i - 0] = arguments[_i];\r\n        }\r\n        // Monitor for invalid paths, throw out empty paths, and look for the *last*\r\n        // absolute path that we see.\r\n        var processed = [];\r\n        for (var i = 0; i < paths.length; i++) {\r\n            var p = paths[i];\r\n            if (typeof p !== 'string') {\r\n                throw new TypeError(\"Invalid argument type to paths.join: \" + (typeof p));\r\n            }\r\n            else if (p !== '') {\r\n                // Remove anything that has occurred before this absolute path, as it\r\n                // doesn't matter.\r\n                if (p.charAt(0) === paths.sep) {\r\n                    processed = [];\r\n                }\r\n                processed.push(p);\r\n            }\r\n        }\r\n        // Special: Remove trailing slash unless it's the root\r\n        var resolved = normalize(processed.join(paths.sep));\r\n        if (resolved.length > 1 && resolved.charAt(resolved.length - 1) === paths.sep) {\r\n            return resolved.substr(0, resolved.length - 1);\r\n        }\r\n        // Special: If it doesn't start with '/', it's relative and we need to append\r\n        // the current directory.\r\n        if (resolved.charAt(0) !== paths.sep) {\r\n            // Remove ./, since we're going to append the current directory.\r\n            if (resolved.charAt(0) === '.' && (resolved.length === 1 || resolved.charAt(1) === paths.sep)) {\r\n                resolved = resolved.length === 1 ? '' : resolved.substr(2);\r\n            }\r\n            // Append the current directory, which *must* be an absolute path.\r\n            var cwd = process.cwd();\r\n            if (resolved !== '') {\r\n                // cwd will never end in a /... unless it's the root.\r\n                resolved = normalize(cwd + (cwd !== '/' ? paths.sep : '') + resolved);\r\n            }\r\n            else {\r\n                resolved = cwd;\r\n            }\r\n        }\r\n        return resolved;\r\n    }\r\n\r\n    return paths.resolve = resolve;\r\n});\ndefine('skylark-langx-paths/main',[\r\n\t\"./paths\",\r\n\t\"./basename\",\r\n\t\"./dirname\",\r\n\t\"./extname\",\r\n\t\"./format\",\r\n\t\"./is-absolute\",\r\n\t\"./join\",\r\n\t\"./normalize\",\r\n\t\"./path\",\r\n\t\"./relative\",\r\n\t\"./resolve\"\r\n],function(paths){\r\n\treturn paths;\r\n});\ndefine('skylark-langx-paths', ['skylark-langx-paths/main'], function (main) { return main; });\n\n"]}