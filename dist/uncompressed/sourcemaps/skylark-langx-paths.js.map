{"version":3,"sources":["skylark-langx-paths.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-langx-paths.js","sourcesContent":["define('skylark-langx-paths/paths',[\r\n\t\"skylark-langx-ns\"\r\n],function(skylark){\r\n\tvar splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\n\r\n\tfunction posixSplitPath(filename) {\r\n\t    var out = splitPathRe.exec(filename);\r\n\t    out.shift();\r\n\t    return out;\r\n\t}\r\n\t/**\r\n\t * Emulates Node's `path` module. This module contains utilities for handling and\r\n\t * transforming file paths. **All** of these methods perform only string\r\n\t * transformations. The file system is not consulted to check whether paths are\r\n\t * valid.\r\n\t * @see http://nodejs.org/api/path.html\r\n\t * @class\r\n\t */\r\n\tvar paths = {};\r\n\r\n\r\n    /**\r\n     * Unknown. Undocumented.\r\n     */\r\n    paths._makeLong = function (p) {\r\n        return p;\r\n    };\r\n\r\n\r\n    paths._removeDuplicateSeps = function (p) {\r\n        p = p.replace(this._replaceRegex, this.sep);\r\n        return p;\r\n    };\r\n\r\n    // The platform-specific file separator. BrowserFS uses `/`.\r\n    paths.sep = '/';\r\n    paths._replaceRegex = new RegExp(\"//+\", 'g');\r\n    // The platform-specific path delimiter. BrowserFS uses `:`.\r\n    paths.delimiter = ':';\r\n    paths.posix = paths;\r\n    // XXX: Typing hack. We don't actually support win32.\r\n    paths.win32 = paths;\r\n\r\n\r\n\treturn skylark.attach(\"langx.paths\",paths);\r\n});\ndefine('skylark-langx-paths/normalize',[\r\n\t\"./paths\"\r\n],function(paths){\r\n    /**\r\n     * Normalize a string path, taking care of '..' and '.' parts.\r\n     *\r\n     * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\r\n     * @example Usage example\r\n     *   paths.normalize('/foo/bar//baz/asdf/quux/..')\r\n     *   // returns\r\n     *   '/foo/bar/baz/asdf'\r\n     * @param [String] p The path to normalize.\r\n     * @return [String]\r\n     */\r\n     function normalize(p) {\r\n        // Special case: '' -> '.'\r\n        if (p === '') {\r\n            p = '.';\r\n        }\r\n        // It's very important to know if the path is relative or not, since it\r\n        // changes how we process .. and reconstruct the split string.\r\n        var absolute = p.charAt(0) === paths.sep;\r\n        // Remove repeated //s\r\n        p = paths._removeDuplicateSeps(p);\r\n        // Try to remove as many '../' as possible, and remove '.' completely.\r\n        var components = p.split(paths.sep);\r\n        var goodComponents = [];\r\n        for (var idx = 0; idx < components.length; idx++) {\r\n            var c = components[idx];\r\n            if (c === '.') {\r\n                continue;\r\n            }\r\n            else if (c === '..' && (absolute || (!absolute && goodComponents.length > 0 && goodComponents[0] !== '..'))) {\r\n                // In the absolute case: Path is relative to root, so we may pop even if\r\n                // goodComponents is empty (e.g. /../ => /)\r\n                // In the relative case: We're getting rid of a directory that preceded\r\n                // it (e.g. /foo/../bar -> /bar)\r\n                goodComponents.pop();\r\n            }\r\n            else {\r\n                goodComponents.push(c);\r\n            }\r\n        }\r\n        // Add in '.' when it's a relative path with no other nonempty components.\r\n        // Possible results: '.' and './' (input: [''] or [])\r\n        // @todo Can probably simplify this logic.\r\n        if (!absolute && goodComponents.length < 2) {\r\n            switch (goodComponents.length) {\r\n                case 1:\r\n                    if (goodComponents[0] === '') {\r\n                        goodComponents.unshift('.');\r\n                    }\r\n                    break;\r\n                default:\r\n                    goodComponents.push('.');\r\n            }\r\n        }\r\n        p = goodComponents.join(paths.sep);\r\n        if (absolute && p.charAt(0) !== paths.sep) {\r\n            p = paths.sep + p;\r\n        }\r\n        return p;\r\n    }\r\n\r\n    return paths.normalize = normalize;\r\n});\ndefine('skylark-langx-paths/basename',[\r\n\t\"./paths\",\r\n    \"./normalize\"\r\n],function(paths,normalize){\r\n    /**\r\n     * Return the last portion of a path. Similar to the Unix basename command.\r\n     * @example Usage example\r\n     *   paths.basename('/foo/bar/baz/asdf/quux.html')\r\n     *   // returns\r\n     *   'quux.html'\r\n     *\r\n     *   paths.basename('/foo/bar/baz/asdf/quux.html', '.html')\r\n     *   // returns\r\n     *   'quux'\r\n     * @param [String] p\r\n     * @param [String?] ext\r\n     * @return [String]\r\n     */\r\n    function basename(p, ext) {\r\n        if (ext === void 0) { ext = \"\"; }\r\n        // Special case: Normalize will modify this to '.'\r\n        if (p === '') {\r\n            return p;\r\n        }\r\n        // Normalize the string first to remove any weirdness.\r\n        p = normalize(p);\r\n        // Get the last part of the string.\r\n        var sections = p.split(paths.sep);\r\n        var lastPart = sections[sections.length - 1];\r\n        // Special case: If it's empty, then we have a string like so: foo/\r\n        // Meaning, 'foo' is guaranteed to be a directory.\r\n        if (lastPart === '' && sections.length > 1) {\r\n            return sections[sections.length - 2];\r\n        }\r\n        // Remove the extension, if need be.\r\n        if (ext.length > 0) {\r\n            var lastPartExt = lastPart.substr(lastPart.length - ext.length);\r\n            if (lastPartExt === ext) {\r\n                return lastPart.substr(0, lastPart.length - ext.length);\r\n            }\r\n        }\r\n        return lastPart;\r\n    }\r\n\r\n    return paths.basename = basename;\r\n});\ndefine('skylark-langx-paths/dirname',[\r\n\t\"./paths\"\r\n],function(paths){\r\n    /**\r\n     * Return the directory name of a path. Similar to the Unix `dirname` command.\r\n     *\r\n     * Note that BrowserFS does not validate if the path is actually a valid\r\n     * directory.\r\n     * @example Usage example\r\n     *   paths.dirname('/foo/bar/baz/asdf/quux')\r\n     *   // returns\r\n     *   '/foo/bar/baz/asdf'\r\n     * @param [String] p The path to get the directory name of.\r\n     * @return [String]\r\n     */\r\n    function dirname(p) {\r\n        // We get rid of //, but we don't modify anything else (e.g. any extraneous .\r\n        // and ../ are kept intact)\r\n        p = paths._removeDuplicateSeps(p);\r\n        var absolute = p.charAt(0) === paths.sep;\r\n        var sections = p.split(paths.sep);\r\n        // Do 1 if it's /foo/bar, 2 if it's /foo/bar/\r\n        if (sections.pop() === '' && sections.length > 0) {\r\n            sections.pop();\r\n        }\r\n        // # of sections needs to be > 1 if absolute, since the first section is '' for '/'.\r\n        // If not absolute, the first section is the first part of the path, and is OK\r\n        // to return.\r\n        if (sections.length > 1 || (sections.length === 1 && !absolute)) {\r\n            return sections.join(paths.sep);\r\n        }\r\n        else if (absolute) {\r\n            return paths.sep;\r\n        }\r\n        else {\r\n            return '.';\r\n        }\r\n    }\r\n\r\n    return paths.dirname = dirname;\r\n});\ndefine('skylark-langx-paths/extname',[\r\n\t\"./paths\",\r\n    \"./normalize\"\r\n],function(paths,normalize){\r\n    /**\r\n     * Return the extension of the path, from the last '.' to end of string in the\r\n     * last portion of the path. If there is no '.' in the last portion of the path\r\n     * or the first character of it is '.', then it returns an empty string.\r\n     * @example Usage example\r\n     *   paths.extname('index.html')\r\n     *   // returns\r\n     *   '.html'\r\n     *\r\n     *   paths.extname('index.')\r\n     *   // returns\r\n     *   '.'\r\n     *\r\n     *   paths.extname('index')\r\n     *   // returns\r\n     *   ''\r\n     * @param [String] p\r\n     * @return [String]\r\n     */\r\n    function extname(p) {\r\n        p = normalize(p);\r\n        var sections = p.split(paths.sep);\r\n        p = sections.pop();\r\n        // Special case: foo/file.ext/ should return '.ext'\r\n        if (p === '' && sections.length > 0) {\r\n            p = sections.pop();\r\n        }\r\n        if (p === '..') {\r\n            return '';\r\n        }\r\n        var i = p.lastIndexOf('.');\r\n        if (i === -1 || i === 0) {\r\n            return '';\r\n        }\r\n        return p.substr(i);\r\n    }\r\n\r\n    return paths.extname = extname;\r\n});\ndefine('skylark-langx-paths/format',[\r\n\t\"./paths\"\r\n],function(paths){\r\n    function format(pathObject) {\r\n        if (pathObject === null || typeof pathObject !== 'object') {\r\n            throw new TypeError(\"Parameter 'pathObject' must be an object, not \" + typeof pathObject);\r\n        }\r\n        var root = pathObject.root || '';\r\n        if (typeof root !== 'string') {\r\n            throw new TypeError(\"'pathObject.root' must be a string or undefined, not \" +\r\n                typeof pathObject.root);\r\n        }\r\n        var dir = pathObject.dir ? pathObject.dir + paths.sep : '';\r\n        var base = pathObject.base || '';\r\n        return dir + base;\r\n    }\r\n\r\n    return paths.format = format;\r\n});\ndefine('skylark-langx-paths/is-absolute',[\r\n\t\"./paths\"\r\n],function(paths){\r\n\r\n    /**\r\n     * Checks if the given path is an absolute path.\r\n     *\r\n     * Despite not being documented, this is a tested part of Node's path API.\r\n     * @param [String] p\r\n     * @return [Boolean] True if the path appears to be an absolute path.\r\n     */\r\n    function isAbsolute(p) {\r\n        return p.length > 0 && p.charAt(0) === paths.sep;\r\n    }\r\n\r\n    return paths.isAbsolute = isAbsolute;\r\n\r\n});\ndefine('skylark-langx-paths/join',[\r\n\t\"./paths\",\r\n    \"./normalize\"\r\n],function(paths,normalize){\r\n    /**\r\n     * Join all arguments together and normalize the resulting path.\r\n     *\r\n     * Arguments must be strings.\r\n     * @example Usage\r\n     *   paths.join('/foo', 'bar', 'baz/asdf', 'quux', '..')\r\n     *   // returns\r\n     *   '/foo/bar/baz/asdf'\r\n     *\r\n     *   paths.join('foo', {}, 'bar')\r\n     *   // throws exception\r\n     *   TypeError: Arguments to paths.join must be strings\r\n     * @param [String,...] segs Each component of the path\r\n     * @return [String]\r\n     */\r\n    function join() {\r\n        var segs = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            segs[_i - 0] = arguments[_i];\r\n        }\r\n        // Required: Prune any non-strings from the path. I also prune empty segments\r\n        // so we can do a simple join of the array.\r\n        var processed = [];\r\n        for (var i = 0; i < segs.length; i++) {\r\n            var segment = segs[i];\r\n            if (typeof segment !== 'string') {\r\n                throw new TypeError(\"Invalid argument type to segs.join: \" + (typeof segment));\r\n            }\r\n            else if (segment !== '') {\r\n                processed.push(segment);\r\n            }\r\n        }\r\n        return normalize(processed.join(paths.sep));\r\n    }\r\n\r\n    return paths.join = join;\r\n});\ndefine('skylark-langx-paths/path',[\r\n    \"skylark-langx-types\",\r\n    \"skylark-langx-constructs\",\r\n    \"./paths\"\r\n], function(types,constructs,paths) {\r\n\r\n    /**\r\n     * @class Path\r\n     * @constructor\r\n     */\r\n    var Path =   constructs.klass({\r\n        _construct : function() {\r\n            var _ = this._ = {\r\n                segments : null,\r\n                hasLeading : false,\r\n                hasTrailing : false\r\n            };\r\n            if (arguments.length == 1 && types.isString(arguments[0])) {\r\n                  this._parse(arguments[0]);\r\n            } else  if (types.isArray(arguments[0])){\r\n                _.segments = arguments[0];\r\n                _.hasLeading = arguments[1] || false;\r\n                _.hasTrailing = arguments[2] || false;\r\n                this._canonicalize();                \r\n            }\r\n        },\r\n\r\n        _canonicalize: function() {\r\n            var doIt;\r\n            var segments = this._.segments;\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (segments[i] == \".\" || segments[i] == \"..\") {\r\n                    doIt = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (doIt) {\r\n                var stack = [];\r\n                for (var i = 0; i < segments.length; i++) {\r\n                    if (segments[i] == \"..\") {\r\n                        if (stack.length == 0) {\r\n                            // if the stack is empty we are going out of our scope\r\n                            // so we need to accumulate segments.  But only if the original\r\n                            // path is relative.  If it is absolute then we can't go any higher than\r\n                            // root so simply toss the .. references.\r\n                            if (!this.hasLeading) {\r\n                                stack.push(segments[i]); //stack push\r\n                            }\r\n                        } else {\r\n                            // if the top is '..' then we are accumulating segments so don't pop\r\n                            if (\"..\" == stack[stack.length - 1]) {\r\n                                stack.push(\"..\");\r\n                            } else {\r\n                                stack.pop();\r\n                            }\r\n                        }\r\n                        //collapse current references\r\n                    } else if (segments[i] != \".\" || segments.length == 1) {\r\n                        stack.push(segments[i]); //stack push\r\n                    }\r\n                }\r\n                //if the number of segments hasn't changed, then no modification needed\r\n                if (stack.length == segments.length) {\r\n                    return;\r\n                }\r\n                this._.segments = stack;\r\n            }\r\n        },\r\n\r\n        _length: function(anotherPath) {\r\n            return this._.segments.length;\r\n        },\r\n\r\n\r\n        _parse : function( /*String*/ path) {\r\n            if (!path) {\r\n                path = \".\";\r\n            }\r\n            var _ = this._,\r\n                segments = path.split(\"/\");\r\n\r\n            if (path.charAt(0) == \"/\") {\r\n                _.hasLeading = true;\r\n                segments.shift();\r\n            }\r\n            if (path.charAt(path.length - 1) == \"/\") {\r\n                _.hasTrailing = true;\r\n                // If the path ends in '/', split() will create an array whose last element\r\n                // is an empty string. Remove that here.\r\n                segments.pop();\r\n            }\r\n            _.segments = segments;\r\n            _.path = path;\r\n\r\n            this._canonicalize()\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method append\r\n         *@parameter {Path|String}tail\r\n         *@return {Path}\r\n         */\r\n        append: /*Path*/ function( /*Path*/ tail) {\r\n            if (types.isString(tail)) {\r\n                return this.appendPathStr(tail);\r\n            } else {\r\n                return this.appendPath(tail);\r\n            }\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method appendPath\r\n         *@parameter {Path}tail\r\n         *@return {Path}\r\n         */\r\n        appendPath: /*Path*/ function( /*Path*/ tail) {\r\n            if (tail.isAbsolute()) {\r\n                return tail;\r\n            }\r\n            var mySegments = this.segments,\r\n                tailSegments = tail.segments,\r\n                newSegments = mySegments.concat(tailSegments),\r\n                result = new Path(newSegments, this.hasLeading, tail.hasTrailing);\r\n            return result;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method appendPathStr\r\n         *@parameter {String}tail\r\n         *@return {Path}\r\n         */\r\n        appendPathStr: function( /*String*/ tail) {\r\n            tail = new Path(tail || \"\");\r\n            return this.appendPath(tail);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method clone\r\n         *@return {Path}\r\n         */\r\n        \"clone\": function() {\r\n            return new Path(this.segments, this.hasLeading, this.hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *Tests if this path ends with the given path.\r\n         *@method endsWidth\r\n         *@parameter {String}tail\r\n         *@return {Boolean}\r\n         */\r\n        \"endsWith\": /*Boolean*/ function( /*String*/ tail) {\r\n            var segments = this.segments;\r\n            var tailSegments = (new Path(tail)).segments;\r\n            while (tailSegments.length > 0 && segments.length > 0) {\r\n                if (tailSegments.pop() != segments.pop()) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        },\r\n\r\n        /*\r\n         *Tests this path for equality with the given object.\r\n         *@method equals\r\n         *@parameter {Path}another\r\n         *@return {Boolean}\r\n         */\r\n        \"equals\": /*Boolean*/ function( /*Path*/ another) {\r\n            var segments = this._.segments,\r\n                anotherSegments = another._.segments;\r\n            if (segments.length != anotherSegments.length) {\r\n                return false;\r\n            }\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (anotherSegments[i] != segments[i]) {\r\n                    return false;\r\n                };\r\n            }\r\n            return true;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method firstSegment\r\n         *@parameter {Number}length\r\n         *@return {String}\r\n         */\r\n        firstSegment: /*String*/ function( /*Number*/ length) {\r\n            var segments = this._.segments;\r\n            return segments[length || 0];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method getExtension\r\n         *@return {String}\r\n         */\r\n        getExtension: function() {\r\n            var extension = this._.extension,\r\n                path = this._.path;\r\n            if (!textension) {\r\n                extension = this._.extension = path.substr(path.lastIndexOf('.') + 1);\r\n            }\r\n            return extension;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method getSegments\r\n         *@return {Array}\r\n         */\r\n        getSegments: /*Array*/ function() {\r\n            return this.segments;\r\n        },\r\n\r\n        /*\r\n         *Returns the parent path, or null if this path does not have a parent.\r\n         *@method getParentPath\r\n         *@return {Path}\r\n         */\r\n        getParentPath: /*Path*/ function() {\r\n            var parentPath = this._.parentPath;\r\n            if (!parentPath) {\r\n                var parentSegments = this.segments;\r\n                parentSegments.pop();\r\n                parentPath = this._.parentPath = new Path(parentSegments, this.hasLeading);\r\n            }\r\n            return parentPath;\r\n        },\r\n\r\n\r\n        /*\r\n         *Returns the root component of this path as a Path object, or null if this path does not have a root component.\r\n         *@method getRoot\r\n         *@return {Path}\r\n         */\r\n        \"getRoot\": /*Path*/ function() {\r\n            //TODO: will be implemented\r\n        },\r\n\r\n        /*\r\n         *Tells whether or not this path is absolute.\r\n         *@method isAbsolute\r\n         *@return {Boolean}\r\n         */\r\n        isAbsolute: /*Boolean*/ function() {\r\n            return this.hasLeading;\r\n        },\r\n\r\n\r\n        /*\r\n         *\r\n         *@method lastSegment\r\n         *@ return {String}\r\n         */\r\n        lastSegment: /*String*/ function() {\r\n            var segments = this._.segments;\r\n            return segments[segments.length - 1];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method matchingFirstSegments\r\n         *@parameter {Path}another\r\n         *@return {Number}\r\n         */\r\n        matchingFirstSegments: /*Number*/ function( /*Path*/ another) {\r\n            var mySegments = this.segments;\r\n            var pathSegments = another.segments;\r\n            var max = Math.min(mySegments.length, pathSegments.length);\r\n            var count = 0;\r\n            for (var i = 0; i < max; i++) {\r\n                if (mySegments[i] != pathSegments[i]) {\r\n                    return count;\r\n                }\r\n                count++;\r\n            }\r\n            return count;\r\n        },\r\n\r\n        /*\r\n         *Returns a path that is this path with redundant name elements eliminated.\r\n         *@method normalize\r\n         *@return {Path}\r\n         */\r\n        \"normalize\": /*Path*/ function() {\r\n            //TODO: will be implemented\r\n        },\r\n\r\n\r\n        /*\r\n         *\r\n         *@method removeFirstSegments\r\n         *@parameter {Number}count\r\n         *@return {Path}\r\n         */\r\n        removeFirstSegments: /*Path*/ function( /*Number*/ count) {\r\n            var segments = this._.segments,\r\n                hasLeading = this._.hasLeading;\r\n            hasTrailing = this._.hasTrailing;\r\n\r\n            return new Path(segments.slice(count, segments.length), hasLeading, hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeLastSegments\r\n         *@parameter {Number}count\r\n         *@return {Path}\r\n         */\r\n        removeLastSegments: /*Path*/ function( /*Number?*/ count) {\r\n            var segments = this._.segments,\r\n                hasLeading = this._.hasLeading;\r\n            hasTrailing = this._.hasTrailing;\r\n\r\n            if (!count) {\r\n                count = 1;\r\n            }\r\n\r\n            return new Path(segments.slice(0, segments.length - count), hasLeading, hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeMatchingFirstSegments\r\n         *@parameter {Path}another\r\n         *@return {Path}\r\n         */\r\n        removeMatchingFirstSegments: /*Path*/ function( /*Path*/ another) {\r\n            var match = this.matchingFirstSegments(another);\r\n            return this.removeFirstSegments(match);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeMatchingLastSegments\r\n         *@parameter {Path}another\r\n         *@return {Path}\r\n         */\r\n        removeMatchingLastSegments: /*Path*/ function( /*Path*/ another) {\r\n            var match = this.matchingFirstSegments(anotherPath);\r\n            return this.removeLastSegments(match);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeRelative\r\n         *@return {Path}\r\n         */\r\n        removeRelative: function() {\r\n            var segs = this.segments;\r\n            if (segs.length > 0 && segs[1] == \".\")\r\n                return this.removeFirstSegments(1);\r\n            return this;\r\n        },\r\n\r\n        /*\r\n         *Constructs a relative path between this path and a given path.\r\n         *@method relativeTo\r\n         *@parameter {Path}base\r\n         *@return {Path}\r\n         */\r\n        relativeTo: /*Path*/ function( /*Path|String*/ base, /*Boolean*/ ignoreFilename) {\r\n            if (typeof base == 'string') {\r\n                base = new Path(base);\r\n            }\r\n            var mySegments = this.segments;\r\n            if (this.isAbsolute()) {\r\n                return this;\r\n            }\r\n            var baseSegments = base.segments;\r\n            var commonLength = this.matchingFirstSegments(base);\r\n            var baseSegmentLength = baseSegments.length;\r\n            if (ignoreFilename) {\r\n                baseSegmentLength = baseSegmentLength - 1;\r\n            }\r\n            var differenceLength = baseSegmentLength - commonLength;\r\n            var newSegmentLength = differenceLength + mySegments.length - commonLength;\r\n            if (newSegmentLength == 0) {\r\n                return Path.EMPTY;\r\n            }\r\n            var newSegments = [];\r\n            for (var i = 0; i < differenceLength; i++) {\r\n                newSegments.push('..');\r\n            }\r\n            for (var i = commonLength; i < mySegments.length; i++) {\r\n                newSegments.push(mySegments[i]);\r\n            }\r\n            return new Path(newSegments, false, this.hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method segment\r\n         *@parameter {Number}index\r\n         *@return {String}\r\n         */\r\n        segment: /*String*/ function( /*Number*/ index) {\r\n            var segments = this._.segments;\r\n            if (segments.length < index) return null;\r\n            return segments[index];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method startsWith\r\n         *@parameter {Path}index\r\n         *@return {Boolean}\r\n         */\r\n        startsWith: /*Boolean*/ function( /*Path*/ another) {\r\n            var count = this.matchingFirstSegments(another);\r\n            return another._length() == count;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method toString\r\n         *@return {String}\r\n         */\r\n        toString: function() {\r\n            var result = [],\r\n                segments = this._.segments;\r\n            if (this.hasLeading) {\r\n                result.push(\"/\");\r\n            }\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (i > 0) {\r\n                    result.push(\"/\");\r\n                }\r\n                result.push(segments[i]);\r\n            }\r\n            if (this.hasTrailing) {\r\n                result.push(\"/\");\r\n            }\r\n            return result.join(\"\");\r\n        },\r\n\r\n        hasLeading : {\r\n            get : function() {\r\n                return this._.hasLeading\r\n            }\r\n        },\r\n\r\n        hasTrailing : {\r\n            get : function() {\r\n                return this._.hasTrailing\r\n            }\r\n        }\r\n\r\n    });\r\n\r\n\r\n    Path.EMPTY = new Path(\"\");\r\n\r\n    return paths.Path = Path;\r\n});\r\n\ndefine('skylark-langx-paths/resolve',[\r\n    \"./paths\",\r\n    \"./normalize\"\r\n],function(paths,normalize){\r\n    /**\r\n     * Resolves to to an absolute path.\r\n     *\r\n     * If to isn't already absolute from arguments are prepended in right to left\r\n     * order, until an absolute path is found. If after using all from paths still\r\n     * no absolute path is found, the current working directory is used as well.\r\n     * The resulting path is normalized, and trailing slashes are removed unless\r\n     * the path gets resolved to the root directory. Non-string arguments are\r\n     * ignored.\r\n     *\r\n     * Another way to think of it is as a sequence of cd commands in a shell.\r\n     *\r\n     *     paths.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')\r\n     *\r\n     * Is similar to:\r\n     *\r\n     *     cd foo/bar\r\n     *     cd /tmp/file/\r\n     *     cd ..\r\n     *     cd a/../subfile\r\n     *     pwd\r\n     *\r\n     * The difference is that the different paths don't need to exist and may also\r\n     * be files.\r\n     * @example Usage example\r\n     *   paths.resolve('/foo/bar', './baz')\r\n     *   // returns\r\n     *   '/foo/bar/baz'\r\n     *\r\n     *   paths.resolve('/foo/bar', '/tmp/file/')\r\n     *   // returns\r\n     *   '/tmp/file'\r\n     *\r\n     *   paths.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')\r\n     *   // if currently in /home/myself/node, it returns\r\n     *   '/home/myself/node/wwwroot/static_files/gif/image.gif'\r\n     * @param [String,...] segs\r\n     * @return [String]\r\n     */\r\n    function resolve() {\r\n        var segs = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            segs[_i - 0] = arguments[_i];\r\n        }\r\n        // Monitor for invalid segs, throw out empty segs, and look for the *last*\r\n        // absolute path that we see.\r\n        var processed = [];\r\n        for (var i = 0; i < segs.length; i++) {\r\n            var p = segs[i];\r\n            if (typeof p !== 'string') {\r\n                throw new TypeError(\"Invalid argument type to paths.join: \" + (typeof p));\r\n            }\r\n            else if (p !== '') {\r\n                // Remove anything that has occurred before this absolute path, as it\r\n                // doesn't matter.\r\n                if (p.charAt(0) === paths.sep) {\r\n                    processed = [];\r\n                }\r\n                processed.push(p);\r\n            }\r\n        }\r\n        // Special: Remove trailing slash unless it's the root\r\n        var resolved = normalize(processed.join(paths.sep));\r\n        if (resolved.length > 1 && resolved.charAt(resolved.length - 1) === paths.sep) {\r\n            return resolved.substr(0, resolved.length - 1);\r\n        }\r\n        /*\r\n        /// \r\n        // Special: If it doesn't start with '/', it's relative and we need to append\r\n        // the current directory.\r\n        if (resolved.charAt(0) !== paths.sep) {\r\n            // Remove ./, since we're going to append the current directory.\r\n            if (resolved.charAt(0) === '.' && (resolved.length === 1 || resolved.charAt(1) === paths.sep)) {\r\n                resolved = resolved.length === 1 ? '' : resolved.substr(2);\r\n            }\r\n            // Append the current directory, which *must* be an absolute path.\r\n            var cwd = process.cwd();\r\n            if (resolved !== '') {\r\n                // cwd will never end in a /... unless it's the root.\r\n                resolved = normalize(cwd + (cwd !== '/' ? paths.sep : '') + resolved);\r\n            }\r\n            else {\r\n                resolved = cwd;\r\n            }\r\n        }\r\n        */\r\n        return resolved;\r\n    }\r\n\r\n    return paths.resolve = resolve;\r\n});\ndefine('skylark-langx-paths/relative',[\r\n\t\"./paths\",\r\n\t\"./resolve\"\r\n],function(paths,resolve){\r\n\r\n    /**\r\n     * Solve the relative path from from to to.\r\n     *\r\n     * At times we have two absolute paths, and we need to derive the relative path\r\n     * from one to the other. This is actually the reverse transform of\r\n     * paths.resolve, which means we see that:\r\n     *\r\n     *    paths.resolve(from, paths.relative(from, to)) == paths.resolve(to)\r\n     *\r\n     * @example Usage example\r\n     *   paths.relative('C:\\\\orandea\\\\test\\\\aaa', 'C:\\\\orandea\\\\impl\\\\bbb')\r\n     *   // returns\r\n     *   '..\\\\..\\\\impl\\\\bbb'\r\n     *\r\n     *   paths.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\r\n     *   // returns\r\n     *   '../../impl/bbb'\r\n     * @param [String] from\r\n     * @param [String] to\r\n     * @return [String]\r\n     */\r\n    function relative(from, to) {\r\n        var i;\r\n        // Alright. Let's resolve these two to absolute paths and remove any\r\n        // weirdness.\r\n        from = resolve(from);\r\n        to = resolve(to);\r\n        var fromSegs = from.split(paths.sep);\r\n        var toSegs = to.split(paths.sep);\r\n        // Remove the first segment on both, as it's '' (both are absolute paths)\r\n        toSegs.shift();\r\n        fromSegs.shift();\r\n        // There are two segments to this path:\r\n        // * Going *up* the directory hierarchy with '..'\r\n        // * Going *down* the directory hierarchy with foo/baz/bat.\r\n        var upCount = 0;\r\n        var downSegs = [];\r\n        // Figure out how many things in 'from' are shared with 'to'.\r\n        for (i = 0; i < fromSegs.length; i++) {\r\n            var seg = fromSegs[i];\r\n            if (seg === toSegs[i]) {\r\n                continue;\r\n            }\r\n            // The rest of 'from', including the current element, indicates how many\r\n            // directories we need to go up.\r\n            upCount = fromSegs.length - i;\r\n            break;\r\n        }\r\n        // The rest of 'to' indicates where we need to change to. We place this\r\n        // outside of the loop, as toSegs.length may be greater than fromSegs.length.\r\n        downSegs = toSegs.slice(i);\r\n        // Special case: If 'from' is '/'\r\n        if (fromSegs.length === 1 && fromSegs[0] === '') {\r\n            upCount = 0;\r\n        }\r\n        // upCount can't be greater than the number of fromSegs\r\n        // (cd .. from / is still /)\r\n        if (upCount > fromSegs.length) {\r\n            upCount = fromSegs.length;\r\n        }\r\n        // Create the final string!\r\n        var rv = '';\r\n        for (i = 0; i < upCount; i++) {\r\n            rv += '../';\r\n        }\r\n        rv += downSegs.join(paths.sep);\r\n        // Special case: Remove trailing '/'. Happens if it's all up and no down.\r\n        if (rv.length > 1 && rv.charAt(rv.length - 1) === paths.sep) {\r\n            rv = rv.substr(0, rv.length - 1);\r\n        }\r\n        return rv;\r\n    }\r\n\r\n    return paths.relative =  relative;\r\n});\ndefine('skylark-langx-paths/main',[\r\n\t\"./paths\",\r\n\t\"./basename\",\r\n\t\"./dirname\",\r\n\t\"./extname\",\r\n\t\"./format\",\r\n\t\"./is-absolute\",\r\n\t\"./join\",\r\n\t\"./normalize\",\r\n\t\"./path\",\r\n\t\"./relative\",\r\n\t\"./resolve\"\r\n],function(paths){\r\n\treturn paths;\r\n});\ndefine('skylark-langx-paths', ['skylark-langx-paths/main'], function (main) { return main; });\n\n"]}